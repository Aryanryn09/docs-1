"use strict";(self.webpackChunkbook=self.webpackChunkbook||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Guide for Developing Wasm Applications","href":"/docs/intro","docId":"intro"},{"type":"category","label":"Quick Start","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"1.1 Install WasmEdge","href":"/docs/quick-start/install","docId":"quick-start/install"},{"type":"link","label":"1.2 Running simple apps","href":"/docs/quick-start/run","docId":"quick-start/run"},{"type":"link","label":"1.3 Using WasmEdge in Docker","href":"/docs/quick-start/use_docker","docId":"quick-start/use_docker"}],"href":"/docs/category/quick-start"},{"type":"category","label":"What is WasmEdge","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"2.1 WasmEdge Features","href":"/docs/wasmedge/features","docId":"wasmedge/features"},{"type":"category","label":"2.2 WasmEdge Extensions","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"2.2.1  Standard WebAssembly proposals","href":"/docs/wasmedge/extensions/proposals","docId":"wasmedge/extensions/proposals"},{"type":"link","label":"2.2.2 WasmEdge extensions","href":"/docs/wasmedge/extensions/unique_extensions","docId":"wasmedge/extensions/unique_extensions"}],"href":"/docs/category/22-wasmedge-extensions"},{"type":"link","label":"2.3 Component Model and Third Party Extensions","href":"/docs/wasmedge/component_model","docId":"wasmedge/component_model"}],"href":"/docs/category/what-is-wasmedge"},{"type":"category","label":"Building and running WasmEdge apps","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"3.1 CLI flags","href":"/docs/build-and-run/cli","docId":"build-and-run/cli"},{"type":"link","label":"3.2 The AoT Compiler","href":"/docs/build-and-run/aot","docId":"build-and-run/aot"},{"type":"link","label":"3.3 Docker + Wasm","href":"/docs/build-and-run/docker_wasm","docId":"build-and-run/docker_wasm"}],"href":"/docs/category/building-and-running-wasmedge-apps"},{"type":"category","label":"Develop Wasm Apps in Rust","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"4.1 Hello world","href":"/docs/rust/hello_world","docId":"rust/hello_world"},{"type":"link","label":"4.2 Access OS services","href":"/docs/rust/os","docId":"rust/os"},{"type":"category","label":"4.3 HTTP services","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"4.3.1 Client","href":"/docs/rust/http_service/client","docId":"rust/http_service/client"},{"type":"link","label":"4.3.1 Server","href":"/docs/rust/http_service/server","docId":"rust/http_service/server"}],"href":"/docs/category/43-http-services"},{"type":"category","label":"4.4 Socket networking","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"4.4.1 Client","href":"/docs/rust/socket_networking/client","docId":"rust/socket_networking/client"},{"type":"link","label":"4.4.1 Server","href":"/docs/rust/socket_networking/server","docId":"rust/socket_networking/server"}],"href":"/docs/category/44-socket-networking"},{"type":"category","label":"4.5 AI Inference","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"4.5.1 TensorFlow","href":"/docs/rust/ai_inference/tensorflow","docId":"rust/ai_inference/tensorflow"},{"type":"link","label":"4.5.2 Pytorch","href":"/docs/rust/ai_inference/pytorch","docId":"rust/ai_inference/pytorch"},{"type":"link","label":"4.5.3 OpenVino","href":"/docs/rust/ai_inference/openvino","docId":"rust/ai_inference/openvino"},{"type":"link","label":"4.5.4 TensorFlow Lite","href":"/docs/rust/ai_inference/tensorflow_lite","docId":"rust/ai_inference/tensorflow_lite"}],"href":"/docs/category/45-ai-inference"},{"type":"link","label":"4.6 MySQL-based Database Driver","href":"/docs/rust/my_sql_driver","docId":"rust/my_sql_driver"},{"type":"link","label":"4.7 Use WasmEdge\'s Dapr SDK to Connect Dapr Sidecar","href":"/docs/rust/dapr","docId":"rust/dapr"}],"href":"/docs/category/develop-wasm-apps-in-rust"},{"type":"category","label":"Developing Wasm Apps in JavaScript","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"5.1 Introduction","href":"/docs/javascript/intro","docId":"javascript/intro"},{"type":"link","label":"5.2 Quick Start with JavaScript on WasmEdge","href":"/docs/javascript/hello_world","docId":"javascript/hello_world"},{"type":"category","label":"HTTP service","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"5.3.1 Client","href":"/docs/javascript/http_service/client","docId":"javascript/http_service/client"},{"type":"link","label":"5.3.2 Server","href":"/docs/javascript/http_service/server","docId":"javascript/http_service/server"}],"href":"/docs/category/http-service"},{"type":"link","label":"5.4 Node.js support","href":"/docs/javascript/nodejs","docId":"javascript/nodejs"},{"type":"link","label":"5.5 ES6 Modules","href":"/docs/javascript/es6","docId":"javascript/es6"},{"type":"link","label":"5.6 Built-in modules","href":"/docs/javascript/modules","docId":"javascript/modules"},{"type":"link","label":"5.7 NodeJS and NPM modules","href":"/docs/javascript/npm","docId":"javascript/npm"},{"type":"link","label":"5.8 Native JS API in Rust","href":"/docs/javascript/rust","docId":"javascript/rust"},{"type":"link","label":"5.9 Example: Running SSR in WasmEdge","href":"/docs/javascript/ssr","docId":"javascript/ssr"}],"href":"/docs/category/developing-wasm-apps-in-javascript"},{"type":"category","label":"Develop Wasm Apps in C/C++","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"6.1 Hello World","href":"/docs/c/hello_world","docId":"c/hello_world"},{"type":"link","label":"6.2 Networking Socket","href":"/docs/c/networking","docId":"c/networking"},{"type":"link","label":"6.3 Thread","href":"/docs/c/threads","docId":"c/threads"},{"type":"link","label":"6.4 SIMD","href":"/docs/c/simd","docId":"c/simd"}],"href":"/docs/category/develop-wasm-apps-in-cc"},{"type":"category","label":"Develop Wasm Apps in Go","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"7.1 TinyGo","href":"/docs/go/hello_world","docId":"go/hello_world"}],"href":"/docs/category/develop-wasm-apps-in-go"},{"type":"category","label":"Deploy WasmEdge apps in Kubernetes ","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"8.1 Introduction","href":"/docs/deploy/intro","docId":"deploy/intro"},{"type":"link","label":"8.2 Deploy with containerd","href":"/docs/deploy/containerd","docId":"deploy/containerd"},{"type":"link","label":"8.2 Deploy with crun","href":"/docs/deploy/crun","docId":"deploy/crun"},{"type":"link","label":"8.3 Deploy with Youki","href":"/docs/deploy/youki","docId":"deploy/youki"},{"type":"category","label":"8.5 Use Cases","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"8.5.1 OpenYurt","href":"/docs/deploy/use-case/openyurt","docId":"deploy/use-case/openyurt"},{"type":"link","label":"8.5.2 SuperEdge","href":"/docs/deploy/use-case/superedge","docId":"deploy/use-case/superedge"},{"type":"link","label":"8.5.3 KubeEdge","href":"/docs/deploy/use-case/kubedge","docId":"deploy/use-case/kubedge"},{"type":"link","label":"8.5.4 Podman","href":"/docs/deploy/use-case/podman","docId":"deploy/use-case/podman"},{"type":"link","label":"8.5.5 Kind","href":"/docs/deploy/use-case/kind","docId":"deploy/use-case/kind"},{"type":"link","label":"8.5.6 Knative","href":"/docs/deploy/use-case/knative","docId":"deploy/use-case/knative"}],"href":"/docs/category/85-use-cases"}],"href":"/docs/category/deploy-wasmedge-apps-in-kubernetes-"}]},"docs":{"build-and-run/aot":{"id":"build-and-run/aot","title":"3.2 The AoT Compiler","description":"One of the most important features of WasmEdge is the AoT compiler. The wasmedgec can compile any wasm file into native machine code (i.e., the AOT compiler). For the pure WebAssembly, the wasmedge tool will execute the WASM in interpreter mode. After compiling with the wasmedgec AOT compiler, the wasmedge tool can execute the WASM in AOT mode which is much faster.","sidebar":"tutorialSidebar"},"build-and-run/cli":{"id":"build-and-run/cli","title":"3.1 CLI flags","description":"After installing WasmEdge, you could use wasmedge CLI flags to excute a compiled wasm file.","sidebar":"tutorialSidebar"},"build-and-run/docker_wasm":{"id":"build-and-run/docker_wasm","title":"3.3 Docker + Wasm","description":"Docker announced its support for WebAssembly in the partnership with WasmEdge. So for WasmEdge developers, you could use Docker Desktop and Docker CLI to build, share and run WasmEdge apps.","sidebar":"tutorialSidebar"},"c/hello_world":{"id":"c/hello_world","title":"6.1 Hello World","description":"This chapter will take Hello World as an example to show how to compile a C program to Wasm bytecode and run in WasmEdge.","sidebar":"tutorialSidebar"},"c/networking":{"id":"c/networking","title":"6.2 Networking Socket","description":"","sidebar":"tutorialSidebar"},"c/simd":{"id":"c/simd","title":"6.4 SIMD","description":"128-bit packed Single Instruction Multiple Data (SIMD) instructions provide simultaneous computations over packed data in just one instruction. It\'s commonly used to improve performance for multimedia applications. With the SIMD proposal, the modules can benefit from using these commonly used instructions in modern hardware to gain more speedup.","sidebar":"tutorialSidebar"},"c/threads":{"id":"c/threads","title":"6.3 Thread","description":"","sidebar":"tutorialSidebar"},"deploy/containerd":{"id":"deploy/containerd","title":"8.2 Deploy with containerd","description":"","sidebar":"tutorialSidebar"},"deploy/crun":{"id":"deploy/crun","title":"8.2 Deploy with crun","description":"The crun project has WasmEdge support baked in. In this chapter, we will walk you through how to deploy Wasm iamges with crun.","sidebar":"tutorialSidebar"},"deploy/intro":{"id":"deploy/intro","title":"8.1 Introduction","description":"WasmEdge could be integrated with the existing cloud native infra seamlessly. So developers can leverage container tools such as Kubernetes, Docker and CRI-O to deploy, manage, and run lightweight WebAssembly applications. In this chapter, we will demonstrate how Kubernetes ecosystem tools work with WasmEdge WebAssembly applications.","sidebar":"tutorialSidebar"},"deploy/use-case/kind":{"id":"deploy/use-case/kind","title":"8.5.5 Kind","description":"KinD is a Kubernetes distribution that runs inside Docker and is well suited for local development or integration testing. It runs containerd as CRI and runc as OCI Runtime.","sidebar":"tutorialSidebar"},"deploy/use-case/knative":{"id":"deploy/use-case/knative","title":"8.5.6 Knative","description":"Knative is a platform-agnostic solution for running serverless deployments.","sidebar":"tutorialSidebar"},"deploy/use-case/kubedge":{"id":"deploy/use-case/kubedge","title":"8.5.3 KubeEdge","description":"KubeEdge is an open source system for extending native containerized application orchestration capabilities to hosts at Edge.","sidebar":"tutorialSidebar"},"deploy/use-case/openyurt":{"id":"deploy/use-case/openyurt","title":"8.5.1 OpenYurt","description":"OpenYurt is the intelligent edge computing platform which aims to extend the Cloud Native ecosystem to edge computing and IoT scenarios.","sidebar":"tutorialSidebar"},"deploy/use-case/podman":{"id":"deploy/use-case/podman","title":"8.5.4 Podman","description":"","sidebar":"tutorialSidebar"},"deploy/use-case/superedge":{"id":"deploy/use-case/superedge","title":"8.5.2 SuperEdge","description":"SuperEdge is an open-source container management system for edge computing. It extends native Kubernetes to the edge in a non-intrusive way.","sidebar":"tutorialSidebar"},"deploy/youki":{"id":"deploy/youki","title":"8.3 Deploy with Youki","description":"","sidebar":"tutorialSidebar"},"go/hello_world":{"id":"go/hello_world","title":"7.1 TinyGo","description":"The best way to run Go programs in WasmEdge is to compile Go source code to WebAssembly using TinyGo. In this article, we will show you how.","sidebar":"tutorialSidebar"},"intro":{"id":"intro","title":"Guide for Developing Wasm Applications","description":"WasmEdge is a lightweight, high-performance, and extensible WebAssembly runtime for cloud native, edge, and decentralized applications. It powers serverless apps, embedded functions, microservices, udf, smart contracts, and IoT devices. WasmEdge is currently a CNCF (Cloud Native Computing Foundation) Sandbox project.","sidebar":"tutorialSidebar"},"javascript/es6":{"id":"javascript/es6","title":"5.5 ES6 Modules","description":"The WasmEdge QuickJS runtime supports ES6 modules. In fact, the rollup commands we used in the React SSR examples convert and bundle CommonJS and NPM modules into ES6 modules so that they can be executed in WasmEdge QuickJS. This article will show you how to use ES6 module in WasmEdge.","sidebar":"tutorialSidebar"},"javascript/hello_world":{"id":"javascript/hello_world","title":"5.2 Quick Start with JavaScript on WasmEdge","description":"Prerequisites","sidebar":"tutorialSidebar"},"javascript/http_service/client":{"id":"javascript/http_service/client","title":"5.3.1 Client","description":"The fetch API is widely used in browser and node-based JavaScript applications to fetch content over the network. Building on top of its non-blocking aysnc network socket API, the WasmEdge QuickJS runtime supports the fetch API. That makes a lot of JS APIs and modules reusable out of the box.","sidebar":"tutorialSidebar"},"javascript/http_service/server":{"id":"javascript/http_service/server","title":"5.3.2 Server","description":"Work in progress","sidebar":"tutorialSidebar"},"javascript/intro":{"id":"javascript/intro","title":"5.1 Introduction","description":"WebAssembly started as a \\"JavaScript alternative for browsers\\". The idea is to run high-performance applications compiled from languages like C/C++ or Rust safely in browsers. In the browser, WebAssembly runs side by side with JavaScript.","sidebar":"tutorialSidebar"},"javascript/modules":{"id":"javascript/modules","title":"5.6 Built-in modules","description":"The WasmEdge QuickJS runtime supports ES6 and NPM modules for application developers. However, those approaches are too cumbersome for system developers. They need an easier way to add multiple JavaScript modules and APIs into the runtime without having to go through build tools like rollup.js. The WasmEdge QuickJS modules system allow developers to just drop JavaScript files into a modules folder, and have the JavaScript functions defined in the files immediately available to all JavaScript programs in the runtime. A good use case for this modules system is to support Node.js APIs in WasmEdge.","sidebar":"tutorialSidebar"},"javascript/nodejs":{"id":"javascript/nodejs","title":"5.4 Node.js support","description":"Many existing JavaScript apps simply use Node.js built-in APIs. In order to support and reuse these JavaScript apps, we are in the process of implementing many Node.JS APIs for WasmEdge QuickJS. The goal is to have unmodified Node.js programs running in WasmEdge QuickJS.","sidebar":"tutorialSidebar"},"javascript/npm":{"id":"javascript/npm","title":"5.7 NodeJS and NPM modules","description":"With rollup.js, we can run CommonJS (CJS) and NodeJS (NPM) modules in WasmEdge too.","sidebar":"tutorialSidebar"},"javascript/rust":{"id":"javascript/rust","title":"5.8 Native JS API in Rust","description":"For JavaScript developers, incorporating Rust functions into JavaScript APIs is useful. That enables developers to write programs in \\"pure JavaScript\\" and yet still take advantage of the high performance Rust functions. With the WasmEdge Runtime, you can do exactly that.","sidebar":"tutorialSidebar"},"javascript/ssr":{"id":"javascript/ssr","title":"5.9 Example: Running SSR in WasmEdge","description":"React is very popular JavaScript web UI framework. A React application is \\"compiled\\" into an HTML and JavaScript static web site. The web UI is rendered through the generated JavaScript code. However, it is often too slow and resource consuming to execute the complex generated JavaScript entirely in the browser to build the interactive HTML DOM objects. React Server Side Rendering (SSR) delegates the JavaScript UI rendering to a server, and have the server stream rendered HTML DOM objects to the browser. The WasmEdge JavaScript runtime provides a lightweight and high performance container to run React SSR functions on edge servers.","sidebar":"tutorialSidebar"},"quick-start/install":{"id":"quick-start/install","title":"1.1 Install WasmEdge","description":"One liner Installation","sidebar":"tutorialSidebar"},"quick-start/run":{"id":"quick-start/run","title":"1.2 Running simple apps","description":"In this chapter, you will learn how to use WasmEdge CLI to run wasm bytecode from Rust in two ways in 5 minutes.","sidebar":"tutorialSidebar"},"quick-start/use_docker":{"id":"quick-start/use_docker","title":"1.3 Using WasmEdge in Docker","description":"WasmEdge DockerSlim","sidebar":"tutorialSidebar"},"rust/ai_inference/openvino":{"id":"rust/ai_inference/openvino","title":"4.5.3 OpenVino","description":"We will use MobileNet as an example to discuss how to do AI inference with OpenVINO in WasmEdge.","sidebar":"tutorialSidebar"},"rust/ai_inference/pytorch":{"id":"rust/ai_inference/pytorch","title":"4.5.2 Pytorch","description":"We will use MobileNet as an example to discuss how to do AI inference with Pytorch in WasmEdge.","sidebar":"tutorialSidebar"},"rust/ai_inference/tensorflow":{"id":"rust/ai_inference/tensorflow","title":"4.5.1 TensorFlow","description":"AI inference is a computationally intensive task that could benefit greatly from the speed of Rust and WebAssembly. However, the standard WebAssembly sandbox provides very limited access to the native OS and hardware, such as multi-core CPUs, GPU and specialized AI inference chips. It is not ideal for the AI workload.","sidebar":"tutorialSidebar"},"rust/ai_inference/tensorflow_lite":{"id":"rust/ai_inference/tensorflow_lite","title":"4.5.4 TensorFlow Lite","description":"We will use MobileNet as an example to discuss how to do AI inference with TensorFlow Lite in WasmEdge.","sidebar":"tutorialSidebar"},"rust/dapr":{"id":"rust/dapr","title":"4.7 Use WasmEdge\'s Dapr SDK to Connect Dapr Sidecar","description":"Second State launched a new WebAssembly-based SDK for the Dapr API, which provides an easy way for Rust-based microservices in WasmEdge to interact with Dapr APIs and sidecar services.","sidebar":"tutorialSidebar"},"rust/hello_world":{"id":"rust/hello_world","title":"4.1 Hello world","description":"Prerequisites","sidebar":"tutorialSidebar"},"rust/http_service/client":{"id":"rust/http_service/client","title":"4.3.1 Client","description":"","sidebar":"tutorialSidebar"},"rust/http_service/server":{"id":"rust/http_service/server","title":"4.3.1 Server","description":"","sidebar":"tutorialSidebar"},"rust/my_sql_driver":{"id":"rust/my_sql_driver","title":"4.6 MySQL-based Database Driver","description":"Database connection is necessary for today\'s enterprise development. WasmEdge provides MySQL-based drivers for Rust developer, enabling developers to build database applications in Rust and then running in WasmEdge.","sidebar":"tutorialSidebar"},"rust/os":{"id":"rust/os","title":"4.2 Access OS services","description":"The WASI (WebAssembly Systems Interface) standard is designed to allow WebAssembly applications to access operating system services.","sidebar":"tutorialSidebar"},"rust/socket_networking/client":{"id":"rust/socket_networking/client","title":"4.4.1 Client","description":"","sidebar":"tutorialSidebar"},"rust/socket_networking/server":{"id":"rust/socket_networking/server","title":"4.4.1 Server","description":"","sidebar":"tutorialSidebar"},"wasmedge/component_model":{"id":"wasmedge/component_model","title":"2.3 Component Model and Third Party Extensions","description":"The component model for Wasm would dramatically improve Wasm module\u2019s reusability and composability. It will allow better access from one Wasm module to other modules and systems, including the operating system APIs (eg, networking).","sidebar":"tutorialSidebar"},"wasmedge/extensions/proposals":{"id":"wasmedge/extensions/proposals","title":"2.2.1  Standard WebAssembly proposals","description":"WebAssembly proposals","sidebar":"tutorialSidebar"},"wasmedge/extensions/unique_extensions":{"id":"wasmedge/extensions/unique_extensions","title":"2.2.2 WasmEdge extensions","description":"A key differentiator of WasmEdge from other WebAssembly runtimes is its support for non-standard extensions. The WebAssembly System Interface (WASI) provides a mechanism for developers to extend WebAssembly efficiently and securely. The WasmEdge team created the following WASI-like extensions based on real-world customer demands.","sidebar":"tutorialSidebar"},"wasmedge/features":{"id":"wasmedge/features","title":"2.1 WasmEdge Features","description":"WasmEdg (project under CNCF) is a lightweight, high-performance, and extensible WebAssembly runtime.","sidebar":"tutorialSidebar"}}}')}}]);