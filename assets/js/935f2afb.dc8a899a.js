"use strict";(self.webpackChunkbook=self.webpackChunkbook||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"category","label":"Getting Started with WasmEdge","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Quick start on Linux","href":"/book/docs/getting-started/quick_start","docId":"getting-started/quick_start"},{"type":"link","label":"Quick start with Docker","href":"/book/docs/getting-started/quick_start_docker","docId":"getting-started/quick_start_docker"},{"type":"link","label":"Quick start with Red Hat","href":"/book/docs/getting-started/quick_start_redhat","docId":"getting-started/quick_start_redhat"}],"href":"/book/docs/category/getting-started-with-wasmedge"},{"type":"link","label":"Guide for Developing Wasm Applications","href":"/book/docs/intro","docId":"intro"},{"type":"category","label":"What is WasmEdge","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"2.1 WasmEdge Features","href":"/book/docs/wasmedge/features","docId":"wasmedge/features"},{"type":"category","label":"2.2 WasmEdge Extensions","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"2.2.1  Standard WebAssembly proposals","href":"/book/docs/wasmedge/extensions/proposals","docId":"wasmedge/extensions/proposals"},{"type":"link","label":"2.2.2 WasmEdge extensions","href":"/book/docs/wasmedge/extensions/unique_extensions","docId":"wasmedge/extensions/unique_extensions"}],"href":"/book/docs/category/22-wasmedge-extensions"},{"type":"link","label":"2.3 Component Model and Third Party Extensions","href":"/book/docs/wasmedge/component_model","docId":"wasmedge/component_model"}],"href":"/book/docs/category/what-is-wasmedge"},{"type":"category","label":"Building and running WasmEdge apps","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Install and uninstall WasmEdge","href":"/book/docs/build-and-run/install","docId":"build-and-run/install"},{"type":"link","label":"The `wasmedge` CLI","href":"/book/docs/build-and-run/cli","docId":"build-and-run/cli"},{"type":"link","label":"The AoT Compiler","href":"/book/docs/build-and-run/aot","docId":"build-and-run/aot"},{"type":"link","label":"Docker + Wasm","href":"/book/docs/build-and-run/docker_wasm","docId":"build-and-run/docker_wasm"}],"href":"/book/docs/category/building-and-running-wasmedge-apps"},{"type":"category","label":"Develop Wasm Apps in Rust","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"4.1 Hello world","href":"/book/docs/rust/hello_world","docId":"rust/hello_world"},{"type":"link","label":"4.0 Set up SoftWare for Building and compiling Rust Programs","href":"/book/docs/rust/setup","docId":"rust/setup"},{"type":"link","label":"4.2 Access OS services","href":"/book/docs/rust/os","docId":"rust/os"},{"type":"category","label":"4.3 HTTP services","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"4.3.1 Client","href":"/book/docs/rust/http_service/client","docId":"rust/http_service/client"},{"type":"link","label":"4.3.1 Server","href":"/book/docs/rust/http_service/server","docId":"rust/http_service/server"}],"href":"/book/docs/category/43-http-services"},{"type":"category","label":"4.4 Socket networking","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"4.4.1 Client","href":"/book/docs/rust/socket_networking/client","docId":"rust/socket_networking/client"},{"type":"link","label":"4.4.1 Server","href":"/book/docs/rust/socket_networking/server","docId":"rust/socket_networking/server"}],"href":"/book/docs/category/44-socket-networking"},{"type":"category","label":"4.5 AI Inference","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"4.5.1 TensorFlow","href":"/book/docs/rust/ai_inference/tensorflow","docId":"rust/ai_inference/tensorflow"},{"type":"link","label":"4.5.2 Pytorch","href":"/book/docs/rust/ai_inference/pytorch","docId":"rust/ai_inference/pytorch"},{"type":"link","label":"4.5.3 OpenVino","href":"/book/docs/rust/ai_inference/openvino","docId":"rust/ai_inference/openvino"},{"type":"link","label":"4.5.4 TensorFlow Lite","href":"/book/docs/rust/ai_inference/tensorflow_lite","docId":"rust/ai_inference/tensorflow_lite"}],"href":"/book/docs/category/45-ai-inference"},{"type":"link","label":"4.6 MySQL-based Database Driver","href":"/book/docs/rust/my_sql_driver","docId":"rust/my_sql_driver"},{"type":"link","label":"4.7 Use WasmEdge\'s Dapr SDK to Connect Dapr Sidecar","href":"/book/docs/rust/dapr","docId":"rust/dapr"}],"href":"/book/docs/category/develop-wasm-apps-in-rust"},{"type":"category","label":"Developing Wasm Apps in JavaScript","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"5.1 Introduction","href":"/book/docs/javascript/intro","docId":"javascript/intro"},{"type":"link","label":"5.2 Quick Start with JavaScript on WasmEdge","href":"/book/docs/javascript/hello_world","docId":"javascript/hello_world"},{"type":"category","label":"HTTP service","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"5.3.1 Client","href":"/book/docs/javascript/http_service/client","docId":"javascript/http_service/client"},{"type":"link","label":"5.3.2 Server","href":"/book/docs/javascript/http_service/server","docId":"javascript/http_service/server"}],"href":"/book/docs/category/http-service"},{"type":"link","label":"5.4 Node.js support","href":"/book/docs/javascript/nodejs","docId":"javascript/nodejs"},{"type":"link","label":"5.5 ES6 Modules","href":"/book/docs/javascript/es6","docId":"javascript/es6"},{"type":"link","label":"5.6 Built-in modules","href":"/book/docs/javascript/modules","docId":"javascript/modules"},{"type":"link","label":"5.7 NodeJS and NPM modules","href":"/book/docs/javascript/npm","docId":"javascript/npm"},{"type":"link","label":"5.8 Native JS API in Rust","href":"/book/docs/javascript/rust","docId":"javascript/rust"},{"type":"link","label":"5.9 Example: Running SSR in WasmEdge","href":"/book/docs/javascript/ssr","docId":"javascript/ssr"}],"href":"/book/docs/category/developing-wasm-apps-in-javascript"},{"type":"category","label":"Develop Wasm Apps in C/C++","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"6.1 Hello World","href":"/book/docs/c/hello_world","docId":"c/hello_world"},{"type":"link","label":"6.2 Networking Socket","href":"/book/docs/c/networking","docId":"c/networking"},{"type":"link","label":"6.3 Thread","href":"/book/docs/c/threads","docId":"c/threads"},{"type":"link","label":"6.4 SIMD","href":"/book/docs/c/simd","docId":"c/simd"}],"href":"/book/docs/category/develop-wasm-apps-in-cc"},{"type":"category","label":"Develop Wasm Apps in Go","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"7.1 TinyGo","href":"/book/docs/go/hello_world","docId":"go/hello_world"}],"href":"/book/docs/category/develop-wasm-apps-in-go"},{"type":"category","label":"Deploy WasmEdge apps in Kubernetes","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"8.1 Introduction","href":"/book/docs/deploy/intro","docId":"deploy/intro"},{"type":"link","label":"8.2 Docker + Wasm","href":"/book/docs/deploy/docker","docId":"deploy/docker"},{"type":"link","label":"8.3 Podman","href":"/book/docs/deploy/podman","docId":"deploy/podman"},{"type":"link","label":"8.4 Kubernetes","href":"/book/docs/deploy/kubernetes","docId":"deploy/kubernetes"},{"type":"category","label":"Low level runtime support","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"8.5.1 Deploy with containerd","href":"/book/docs/deploy/oci-runtime/containerd","docId":"deploy/oci-runtime/containerd"},{"type":"link","label":"8.5.2 Deploy with crun","href":"/book/docs/deploy/oci-runtime/crun","docId":"deploy/oci-runtime/crun"},{"type":"link","label":"8.5.3 Deploy with youki","href":"/book/docs/deploy/oci-runtime/youki","docId":"deploy/oci-runtime/youki"},{"type":"link","label":"8.5.4 Deploy with quark","href":"/book/docs/deploy/oci-runtime/quark","docId":"deploy/oci-runtime/quark"}],"href":"/book/docs/category/low-level-runtime-support"},{"type":"category","label":"Use Cases","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"8.6.1 OpenYurt","href":"/book/docs/deploy/use-case/openyurt","docId":"deploy/use-case/openyurt"},{"type":"link","label":"8.6.2 SuperEdge","href":"/book/docs/deploy/use-case/superedge","docId":"deploy/use-case/superedge"},{"type":"link","label":"8.6.3 KubeEdge","href":"/book/docs/deploy/use-case/kubedge","docId":"deploy/use-case/kubedge"},{"type":"link","label":"8.6.4 Podman","href":"/book/docs/deploy/use-case/podman","docId":"deploy/use-case/podman"},{"type":"link","label":"8.6.5 Kind","href":"/book/docs/deploy/use-case/kind","docId":"deploy/use-case/kind"},{"type":"link","label":"8.6.6 Knative","href":"/book/docs/deploy/use-case/knative","docId":"deploy/use-case/knative"}],"href":"/book/docs/category/use-cases"}],"href":"/book/docs/category/deploy-wasmedge-apps-in-kubernetes"}]},"docs":{"build-and-run/aot":{"id":"build-and-run/aot","title":"The AoT Compiler","description":"One of the most important features of WasmEdge is the AoT compiler. The wasmedgec can compile any wasm file into native machine code (i.e., the AOT compiler). For the pure WebAssembly, the wasmedge tool will execute the WASM in interpreter mode. After compiling with the wasmedgec AOT compiler, the wasmedge tool can execute the WASM in AOT mode which is much faster.","sidebar":"tutorialSidebar"},"build-and-run/cli":{"id":"build-and-run/cli","title":"The `wasmedge` CLI","description":"After installing WasmEdge, you could use the wasmedge CLI to execute a compiled wasm file.","sidebar":"tutorialSidebar"},"build-and-run/docker_wasm":{"id":"build-and-run/docker_wasm","title":"Docker + Wasm","description":"The Docker Desktop distributes with the WasmEdge Runtime embedded. That allows developers to build, share and run very lightweight containers (i.e., a scratch empty container with only the .wasm file without any Linux OS libraries or files) through Docker tools.","sidebar":"tutorialSidebar"},"build-and-run/install":{"id":"build-and-run/install","title":"Install and uninstall WasmEdge","description":"In this chapter, we will discuss ways to install and uninstall the WasmEdge Runtime on various OSes and platforms.","sidebar":"tutorialSidebar"},"c/hello_world":{"id":"c/hello_world","title":"6.1 Hello World","description":"This chapter will take Hello World as an example to show how to compile a C program to Wasm bytecode and run in WasmEdge.","sidebar":"tutorialSidebar"},"c/networking":{"id":"c/networking","title":"6.2 Networking Socket","description":"Work in progress.","sidebar":"tutorialSidebar"},"c/simd":{"id":"c/simd","title":"6.4 SIMD","description":"128-bit packed Single Instruction Multiple Data (SIMD) instructions provide simultaneous computations over packed data in just one instruction. It\'s commonly used to improve performance for multimedia applications. With the SIMD proposal, the modules can benefit from using these commonly used instructions in modern hardware to gain more speedup.","sidebar":"tutorialSidebar"},"c/threads":{"id":"c/threads","title":"6.3 Thread","description":"Work in progress.","sidebar":"tutorialSidebar"},"deploy/docker":{"id":"deploy/docker","title":"8.2 Docker + Wasm","description":"","sidebar":"tutorialSidebar"},"deploy/intro":{"id":"deploy/intro","title":"8.1 Introduction","description":"WasmEdge could be integrated with the existing cloud native infra seamlessly. So developers can leverage container tools such as Kubernetes, Docker and CRI-O to deploy, manage, and run lightweight WebAssembly applications. In this chapter, we will demonstrate how Kubernetes ecosystem tools work with WasmEdge WebAssembly applications.","sidebar":"tutorialSidebar"},"deploy/kubernetes":{"id":"deploy/kubernetes","title":"8.4 Kubernetes","description":"Quick start","sidebar":"tutorialSidebar"},"deploy/oci-runtime/containerd":{"id":"deploy/oci-runtime/containerd","title":"8.5.1 Deploy with containerd","description":"Work in progress.","sidebar":"tutorialSidebar"},"deploy/oci-runtime/crun":{"id":"deploy/oci-runtime/crun","title":"8.5.2 Deploy with crun","description":"The crun project has WasmEdge support baked in. This chapter will walk you through deploying Wasm images with crun.","sidebar":"tutorialSidebar"},"deploy/oci-runtime/quark":{"id":"deploy/oci-runtime/quark","title":"8.5.4 Deploy with quark","description":"Work in progress","sidebar":"tutorialSidebar"},"deploy/oci-runtime/youki":{"id":"deploy/oci-runtime/youki","title":"8.5.3 Deploy with youki","description":"youki is an OCI container runtime written in Rust. youki has WasmEdge baked in. This chapter will walk you through deploying Wasm images with youki.","sidebar":"tutorialSidebar"},"deploy/podman":{"id":"deploy/podman","title":"8.3 Podman","description":"Fedora Platform","sidebar":"tutorialSidebar"},"deploy/use-case/kind":{"id":"deploy/use-case/kind","title":"8.6.5 Kind","description":"KinD is a Kubernetes distribution that runs inside Docker and is well suited for local development or integration testing. It runs containerd as CRI and crun as OCI Runtime.","sidebar":"tutorialSidebar"},"deploy/use-case/knative":{"id":"deploy/use-case/knative","title":"8.6.6 Knative","description":"Knative is a platform-agnostic solution for running serverless deployments.","sidebar":"tutorialSidebar"},"deploy/use-case/kubedge":{"id":"deploy/use-case/kubedge","title":"8.6.3 KubeEdge","description":"KubeEdge is an open source system for extending native containerized application orchestration capabilities to hosts at Edge.","sidebar":"tutorialSidebar"},"deploy/use-case/openyurt":{"id":"deploy/use-case/openyurt","title":"8.6.1 OpenYurt","description":"OpenYurt is the intelligent edge computing platform which aims to extend the Cloud Native ecosystem to edge computing and IoT scenarios.","sidebar":"tutorialSidebar"},"deploy/use-case/podman":{"id":"deploy/use-case/podman","title":"8.6.4 Podman","description":"","sidebar":"tutorialSidebar"},"deploy/use-case/superedge":{"id":"deploy/use-case/superedge","title":"8.6.2 SuperEdge","description":"SuperEdge is an open-source container management system for edge computing. It extends native Kubernetes to the edge in a non-intrusive way.","sidebar":"tutorialSidebar"},"getting-started/quick_start":{"id":"getting-started/quick_start","title":"Quick start on Linux","description":"In this guide, we will walk you through how to quickly install and run the WasmEdge Runtime on a generic Linux distribution (such as Ubuntu, Debian, Raspberry OS or WSL on Windows). Comprehensive and OS-specific installation instructions can be found here.","sidebar":"tutorialSidebar"},"getting-started/quick_start_docker":{"id":"getting-started/quick_start_docker","title":"Quick start with Docker","description":"In this guide, we will walk you through how to quickly run WasmEdge apps in Docker Desktop. There is no additional dependencies as the entire development and runtime environments are managed by Docker Desktop.","sidebar":"tutorialSidebar"},"getting-started/quick_start_redhat":{"id":"getting-started/quick_start_redhat","title":"Quick start with Red Hat","description":"In this guide, we will walk you through how to quickly run WasmEdge apps in Fedora / CentOS / Red Hat Linux / OpenShift systems. There is no additional dependencies as the entire development and runtime environments are managed by OpenSift / Podman.","sidebar":"tutorialSidebar"},"go/hello_world":{"id":"go/hello_world","title":"7.1 TinyGo","description":"The best way to run Go programs in WasmEdge is to compile Go source code to WebAssembly using TinyGo. In this article, we will show you how.","sidebar":"tutorialSidebar"},"intro":{"id":"intro","title":"Guide for Developing Wasm Applications","description":"WasmEdge is a lightweight, high-performance, and extensible WebAssembly runtime for cloud native, edge, and decentralized applications. It powers serverless apps, embedded functions, microservices, udf, smart contracts, and IoT devices. WasmEdge is currently a CNCF (Cloud Native Computing Foundation) Sandbox project.","sidebar":"tutorialSidebar"},"javascript/es6":{"id":"javascript/es6","title":"5.5 ES6 Modules","description":"The WasmEdge QuickJS runtime supports ES6 modules. In fact, the rollup commands we used in the React SSR examples convert and bundle CommonJS and NPM modules into ES6 modules so that they can be executed in WasmEdge QuickJS. This article will show you how to use ES6 module in WasmEdge.","sidebar":"tutorialSidebar"},"javascript/hello_world":{"id":"javascript/hello_world","title":"5.2 Quick Start with JavaScript on WasmEdge","description":"Prerequisites","sidebar":"tutorialSidebar"},"javascript/http_service/client":{"id":"javascript/http_service/client","title":"5.3.1 Client","description":"The fetch API is widely used in browser and node-based JavaScript applications to fetch content over the network. Building on top of its non-blocking async network socket API, the WasmEdge QuickJS runtime supports the fetch API. That makes a lot of JS APIs and modules reusable out of the box.","sidebar":"tutorialSidebar"},"javascript/http_service/server":{"id":"javascript/http_service/server","title":"5.3.2 Server","description":"Work in progress","sidebar":"tutorialSidebar"},"javascript/intro":{"id":"javascript/intro","title":"5.1 Introduction","description":"WebAssembly started as a \\"JavaScript alternative for browsers\\". The idea is to run high-performance applications compiled from languages like C/C++ or Rust safely in browsers. In the browser, WebAssembly runs side by side with JavaScript.","sidebar":"tutorialSidebar"},"javascript/modules":{"id":"javascript/modules","title":"5.6 Built-in modules","description":"The WasmEdge QuickJS runtime supports ES6 and NPM modules for application developers. However, those approaches are too cumbersome for system developers. They need an easier way to add multiple JavaScript modules and APIs into the runtime without having to go through build tools like rollup.js. The WasmEdge QuickJS modules system allow developers to just drop JavaScript files into a modules folder, and have the JavaScript functions defined in the files immediately available to all JavaScript programs in the runtime. A good use case for this modules system is to support Node.js APIs in WasmEdge.","sidebar":"tutorialSidebar"},"javascript/nodejs":{"id":"javascript/nodejs","title":"5.4 Node.js support","description":"Many existing JavaScript apps simply use Node.js built-in APIs. In order to support and reuse these JavaScript apps, we are in the process of implementing many Node.JS APIs for WasmEdge QuickJS. The goal is to have unmodified Node.js programs running in WasmEdge QuickJS.","sidebar":"tutorialSidebar"},"javascript/npm":{"id":"javascript/npm","title":"5.7 NodeJS and NPM modules","description":"With rollup.js, we can run CommonJS (CJS) and NodeJS (NPM) modules in WasmEdge too.","sidebar":"tutorialSidebar"},"javascript/rust":{"id":"javascript/rust","title":"5.8 Native JS API in Rust","description":"For JavaScript developers, incorporating Rust functions into JavaScript APIs is useful. That enables developers to write programs in \\"pure JavaScript\\" and yet still take advantage of the high performance Rust functions. With the WasmEdge Runtime, you can do exactly that.","sidebar":"tutorialSidebar"},"javascript/ssr":{"id":"javascript/ssr","title":"5.9 Example: Running SSR in WasmEdge","description":"React is very popular JavaScript web UI framework. A React application is \\"compiled\\" into an HTML and JavaScript static web site. The web UI is rendered through the generated JavaScript code. However, it is often too slow and resource consuming to execute the complex generated JavaScript entirely in the browser to build the interactive HTML DOM objects. React Server Side Rendering (SSR) delegates the JavaScript UI rendering to a server, and have the server stream rendered HTML DOM objects to the browser. The WasmEdge JavaScript runtime provides a lightweight and high performance container to run React SSR functions on edge servers.","sidebar":"tutorialSidebar"},"rust/ai_inference/openvino":{"id":"rust/ai_inference/openvino","title":"4.5.3 OpenVino","description":"We will use MobileNet as an example to discuss how to do AI inference with OpenVINO in WasmEdge.","sidebar":"tutorialSidebar"},"rust/ai_inference/pytorch":{"id":"rust/ai_inference/pytorch","title":"4.5.2 Pytorch","description":"We will use MobileNet as an example to discuss how to do AI inference with Pytorch in WasmEdge.","sidebar":"tutorialSidebar"},"rust/ai_inference/tensorflow":{"id":"rust/ai_inference/tensorflow","title":"4.5.1 TensorFlow","description":"AI inference is a computationally intensive task that could benefit greatly from the speed of Rust and WebAssembly. However, the standard WebAssembly sandbox provides very limited access to the native OS and hardware, such as multi-core CPUs, GPU and specialized AI inference chips. It is not ideal for the AI workload.","sidebar":"tutorialSidebar"},"rust/ai_inference/tensorflow_lite":{"id":"rust/ai_inference/tensorflow_lite","title":"4.5.4 TensorFlow Lite","description":"We will use MobileNet as an example to discuss how to do AI inference with TensorFlow Lite in WasmEdge.","sidebar":"tutorialSidebar"},"rust/dapr":{"id":"rust/dapr","title":"4.7 Use WasmEdge\'s Dapr SDK to Connect Dapr Sidecar","description":"Second State launched a new WebAssembly-based SDK for the Dapr API, which provides an easy way for Rust-based microservices in WasmEdge to interact with Dapr APIs and sidecar services.","sidebar":"tutorialSidebar"},"rust/hello_world":{"id":"rust/hello_world","title":"4.1 Hello world","description":"Before we started, make sure you have Rust and WasmEdge installed.","sidebar":"tutorialSidebar"},"rust/http_service/client":{"id":"rust/http_service/client","title":"4.3.1 Client","description":"WasmEdge allows Rust developers to use APIs they are already familiar with to access the Internet via the HTTP or HTTPS protocols. In this chapter, we will cover simple synchronous clients, asynchronous clients, as well as clients based on low level hyper and socket APIs. For HTTP servers in WasmEdge, please see the next chapter.","sidebar":"tutorialSidebar"},"rust/http_service/server":{"id":"rust/http_service/server","title":"4.3.1 Server","description":"In order for WasmEdge to become a cloud-native runtime for microservices, it needs to support HTTP servers. By its very nature, the HTTP server is always asynchronous. In this chapter, we will cover simple HTTP servers based on the wrap API, as well as low level hyper and socket APIs.","sidebar":"tutorialSidebar"},"rust/my_sql_driver":{"id":"rust/my_sql_driver","title":"4.6 MySQL-based Database Driver","description":"Database connection is necessary for today\'s enterprise development. WasmEdge provides MySQL-based drivers for Rust developer, enabling developers to build database applications in Rust and then running in WasmEdge.","sidebar":"tutorialSidebar"},"rust/os":{"id":"rust/os","title":"4.2 Access OS services","description":"The WASI (WebAssembly Systems Interface) standard is designed to allow WebAssembly applications to access operating system services.","sidebar":"tutorialSidebar"},"rust/setup":{"id":"rust/setup","title":"4.0 Set up SoftWare for Building and compiling Rust Programs","description":"In the following chapters, we will show how to build and compile Rust programs into Wasm bytecode and then run them in WasmEdge.","sidebar":"tutorialSidebar"},"rust/socket_networking/client":{"id":"rust/socket_networking/client","title":"4.4.1 Client","description":"The wasmedgewasisocket crate enables Rust developers to create networking applications and compile them into WebAssembly for WasmEdge Runtime. One of the key features of WasmEdge is that it supports non-blocking sockets. That allows even a single threaded WASM application to handle concurrent network requests. For example, while the program is waiting for data to stream in from one connection, it can start or handle another connection.","sidebar":"tutorialSidebar"},"rust/socket_networking/server":{"id":"rust/socket_networking/server","title":"4.4.1 Server","description":"As we described in the client chapter, with the WasmEdge socket API, it is also possible for Rust developers to work directly on the socket level. In order for WasmEdge to become a cloud-native runtime for microservices, it needs to support HTTP servers. So, in this chapter, we will discussan HTTP server example and a non-blocking HTTP server example.","sidebar":"tutorialSidebar"},"wasmedge/component_model":{"id":"wasmedge/component_model","title":"2.3 Component Model and Third Party Extensions","description":"The component model for Wasm would dramatically improve Wasm module\u2019s reusability and composability. It will allow better access from one Wasm module to other modules and systems, including the operating system APIs (eg, networking).","sidebar":"tutorialSidebar"},"wasmedge/extensions/proposals":{"id":"wasmedge/extensions/proposals","title":"2.2.1  Standard WebAssembly proposals","description":"WebAssembly proposals","sidebar":"tutorialSidebar"},"wasmedge/extensions/unique_extensions":{"id":"wasmedge/extensions/unique_extensions","title":"2.2.2 WasmEdge extensions","description":"A key differentiator of WasmEdge from other WebAssembly runtimes is its support for non-standard extensions. The WebAssembly System Interface (WASI) provides a mechanism for developers to extend WebAssembly efficiently and securely. The WasmEdge team created the following WASI-like extensions based on real-world customer demands.","sidebar":"tutorialSidebar"},"wasmedge/features":{"id":"wasmedge/features","title":"2.1 WasmEdge Features","description":"WasmEdg (project under CNCF) is a lightweight, high-performance, and extensible WebAssembly runtime.","sidebar":"tutorialSidebar"}}}')}}]);